"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlTemplateHelper = void 0;
const xml_helper_1 = require("./xml-helper");
const xml_relationship_helper_1 = require("./xml-relationship-helper");
class XmlTemplateHelper {
    constructor(archive) {
        this.relType =
            'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide';
        this.relTypeNotes =
            'http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide';
        this.archive = archive;
        this.path = 'ppt/_rels/presentation.xml.rels';
        this.defaultSlideName = 'untitled';
    }
    getCreationIds() {
        return __awaiter(this, void 0, void 0, function* () {
            const archive = this.archive;
            const relationships = yield xml_helper_1.XmlHelper.getTargetsByRelationshipType(archive, this.path, this.relType);
            const creationIds = [];
            for (const slideRel of relationships) {
                const slideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, 'ppt/' + slideRel.file);
                const creationIdSlide = slideXml
                    .getElementsByTagName('p14:creationId')
                    .item(0)
                    .getAttribute('val');
                const elementIds = this.elementCreationIds(slideXml, archive);
                const slideInfo = yield this.getSlideInfo(slideXml, archive, slideRel.file);
                creationIds.push({
                    id: Number(creationIdSlide),
                    number: this.parseSlideRelFile(slideRel.file),
                    elements: elementIds,
                    info: slideInfo,
                });
            }
            return creationIds;
        });
    }
    parseSlideRelFile(slideRelFile) {
        return Number(slideRelFile.replace('slides/slide', '').replace('.xml', ''));
    }
    getSlideInfo(slideXml, archive, slideRelFile) {
        return __awaiter(this, void 0, void 0, function* () {
            let name;
            const slideNoteRels = yield this.getSlideNoteRels(archive, slideRelFile);
            if (slideNoteRels.length > 0) {
                name = yield this.getSlideNameFromNotes(archive, slideNoteRels);
            }
            if (!name) {
                name = this.getNameFromSlideInfo(slideXml);
            }
            name = !name ? this.defaultSlideName : name;
            return {
                name: name,
            };
        });
    }
    getNameFromSlideInfo(slideXml) {
        const slideTitle = slideXml.getElementsByTagName('p:ph');
        if (slideTitle.length && slideTitle[0].getAttribute('type') === 'title') {
            const titleElement = slideTitle[0].parentNode.parentNode.parentNode;
            const nameFragments = this.parseTitleElement(titleElement);
            if (nameFragments.length) {
                return nameFragments.join(' ');
            }
        }
    }
    getSlideNoteRels(archive, slideRelFile) {
        return __awaiter(this, void 0, void 0, function* () {
            const relFileName = slideRelFile.replace('slides', '');
            const slideRels = yield xml_helper_1.XmlHelper.getTargetsByRelationshipType(archive, `ppt/slides/_rels${relFileName}.rels`, this.relTypeNotes);
            return slideRels;
        });
    }
    getSlideNameFromNotes(archive, slideNoteRels) {
        return __awaiter(this, void 0, void 0, function* () {
            const notesFile = slideNoteRels[0].file.replace('../', '');
            const notesXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, 'ppt/' + notesFile);
            const titleElements = notesXml.getElementsByTagName('a:p');
            if (titleElements.length > 0) {
                const nameFragments = this.parseTitleElement(titleElements[0]);
                if (nameFragments.length) {
                    return nameFragments.join('');
                }
            }
        });
    }
    parseTitleElement(titleElement) {
        var _a;
        const nameFragments = [];
        const titleText = titleElement.getElementsByTagName('a:t');
        if (titleText.length) {
            for (const titleTextNode in titleText) {
                if ((_a = titleText[titleTextNode].firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) {
                    nameFragments.push(titleText[titleTextNode].firstChild.nodeValue);
                }
            }
        }
        return nameFragments;
    }
    /**
     * Returns the slide numbers of a given template as a sorted array of integers.
     * @returns {Promise<number[]>} - A promise that resolves to a sorted array of slide numbers in the template.
     */
    getAllSlideNumbers() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const archive = this.archive;
                const xmlRelationshipHelper = new xml_relationship_helper_1.XmlRelationshipHelper();
                const allSlides = (yield xmlRelationshipHelper.initialize(archive, 'presentation.xml.rels', 'ppt/_rels', 'slides/slide'));
                // Extract slide numbers from each slide using the 'number' property and sort the array of integers.
                const slideNumbers = allSlides.map((slide) => slide.number);
                slideNumbers.sort((a, b) => a - b);
                return slideNumbers;
            }
            catch (error) {
                throw new Error(`Error getting slide numbers: ${error.message}`);
            }
        });
    }
    elementCreationIds(slideXml, archive) {
        const slideElements = slideXml.getElementsByTagName('p:cNvPr');
        const elementIds = [];
        for (const item in slideElements) {
            const slideElement = slideElements[item];
            if (slideElement.getAttribute !== undefined) {
                const creationIdElement = slideElement.getElementsByTagName('a16:creationId');
                if (creationIdElement.item(0)) {
                    elementIds.push(this.getElementInfo(slideElement, archive));
                }
            }
        }
        return elementIds;
    }
    getElementInfo(slideElement, archive) {
        const elementName = slideElement.getAttribute('name');
        const slideElementParent = slideElement.parentNode.parentNode;
        let type = slideElementParent.tagName;
        const creationId = slideElement
            .getElementsByTagName('a16:creationId')
            .item(0)
            .getAttribute('id');
        const mapUriType = {
            'http://schemas.openxmlformats.org/drawingml/2006/table': 'table',
            'http://schemas.openxmlformats.org/drawingml/2006/chart': 'chart',
        };
        type = type.replace('p:', '');
        const position = {
            x: 0,
            y: 0,
            cx: 0,
            cy: 0,
        };
        let xFrmTag = 'a:xfrm';
        switch (type) {
            case 'graphicFrame':
                const graphicData = slideElementParent.getElementsByTagName('a:graphicData')[0];
                const uri = graphicData.getAttribute('uri');
                type = mapUriType[uri] ? mapUriType[uri] : type;
                xFrmTag = 'p:xfrm';
                break;
        }
        const xFrm = slideElementParent.getElementsByTagName(xFrmTag);
        if (xFrm && xFrm.length) {
            const Off = xFrm[0].getElementsByTagName('a:off');
            const Ext = xFrm[0].getElementsByTagName('a:ext');
            position.x = Number(Off[0].getAttribute('x'));
            position.y = Number(Off[0].getAttribute('y'));
            position.cx = Number(Ext[0].getAttribute('cx'));
            position.cy = Number(Ext[0].getAttribute('cy'));
        }
        return {
            name: elementName,
            type: type,
            id: creationId,
            position: position,
        };
    }
}
exports.XmlTemplateHelper = XmlTemplateHelper;
//# sourceMappingURL=xml-template-helper.js.map